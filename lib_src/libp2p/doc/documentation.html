<html>
<head>
<title>P2P Documentation</title>


</head>
<body>

<table>
<tr><td width="640">

<h2>About</h2>

<h3>Summary</h3>
<p>
LibP2P does multi-source segmented downloading meaning that one file is
downloaded from multiple hosts concurrently to increase speed.
</p>

<h3>Goals</h3>

<p>
<b>Bandwidth Efficiency:</b> Ratio of control and error detection data to file
data is kept as low as possible.
</p>

<p>
<b>Perfect Copies:</b> The integrity of files is checked with hash functions to
insure downloaded files are perfect copies of the original.
</p>

<p>
<b>Unpoisonable:</b> The presence of malicious peers has minimal impact on file
downloads.
</p>

<p>
<b>Obfuscation:</b> The protocol is obfuscated to make detecting the protocol
difficult. This does not take precedence over any other goal.
</p>

<p>
<b>Low Requirements:</b> CPU and memory usage is as low as is reasonable.
</p>

<hr>

<h2>Protocol</h2>
<p>
The protocol is symmetric with the exception of the key exchange. Any message
can go in either direction. All numbers are big-endian.
</p>

<h3>Key Exchange</h2>
<pre>
Each session starts with a Diffie-Hellman-Merkle key exchange.

Host_A initiates a connection with Host_B.
g   = the generator both sides use that is always equal to 2
s_A = secret exponent of Host_A
s_B = secret exponent of Host_B
p   = prime Host_A generates that both sides use
r_A = result of Host_A, g^s_A % p
r_B = result of Host_B, g^s_B % p
k   = secret key
MiM = Man in the middle.
^   = exponentiation symbol
%   = modulo symbol

The section header indicates who sees what.
+-----------------+   +-----------------+   +-----------------+
|     Host_A      |   |       MiM       |   |      Host_B     |
+-----------------+   +-----------------+   +-----------------+
| k = r_B^s_A % p | = | g^(s_A*s_B) % p | = | r_A^s_B % p = k |
+-----------------+   +-----------------+   +-----------------+
</pre>

<br>

<fieldset>
<pre>
Step 0: Host_A sends p and r_A to Host_B.

	+---+---+---+---+---+---+---+---+
	|       P       |      r_A      |
	+---+---+---+---+---+---+---+---+
	  0    ...   15   16   ...   31
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Step 1: Host_B receives what was sent in Step 0. Host_B sends r_B to Host_A.

	+---+---+---+---+
	|      r_B      |
	+---+---+---+---+
	  0    ...   15
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Step 2: Host_A receives what was sent in Step 1.
Both sides now have all information needed to calculate the secret key.
</pre>
</fieldset>

<br>

<p>
The secret key is used to seed two KISS PRNGs by George Marsaglia. One PRNG is
for sending and one is for receiving.
</p>

<pre>
/*
To seed the PRNG x, y, z, c must be set. We set these to the secret key.
x = k[0]  .. k[3]
y = k[4]  .. k[7]
z = k[8]  .. k[11]
c = k[12] .. k[15]
*/
uint32_t x, y, z, c;
uint54_t t, a = 698769069LL;
unsigned long KISS(){
	x = 69069 * x + 12345;
	y ^= (y << 13);
	y ^= (y >> 17);
	y ^= (y << 5);
	t = a * z + c;
	c = (t >> 32);
	return x + y + (z = t);
}
</pre>

<p>
After the PRNG is seeded all bytes sent and received are XOR'd against the
output of the PRNGs. The send PRNG of Host_A remains synchronized to the recv
PRNG of Host_B and vise versa.
</p>

<br>

<h3>Requests</h2>

<fieldset>
<pre>
Name: REQUEST_SLOT
Base10: 0
Description: Request a slot for downloading a hash tree and file.

	+---+---+---+---+---+---+---+---+
	| C |             R             |
	+---+---+---+---+---+---+---+---+
	  0   1   2   3   ........    20

	C = command, R = root hash (binary)

Possible Responses:
SLOT_ID
SLOT_ID_WITH_BITFIELD
ERROR (the server does not have the hash tree and file)
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: REQUEST_BLOCK_HASH_TREE
Base10: 2
Description: Request a block from a hash tree.

	+---+---+---+---+---+---+
	| C | S |       B       |
	+---+---+---+---+---+---+
	  0   1   2   3   4   5

	C = command, S = slot ID, B = block number

Possible Responses:
BLOCK
ERROR (the server no longer has the file)
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: REQUEST_BLOCK_FILE
Base10: 3
Description: Request a block from a file.

	+---+---+---+---+---+---+
	| C | S |       B       |
	+---+---+---+---+---+---+
	  0   1   2   3   4   5

	C = command, S = slot ID, B = block number

Possible Responses:
BLOCK
ERROR (the server no longer has the file)
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: CLOSE_SLOT
Base10: 4
Description: This is done after a hash tree or file is finished downloading.

	+---+---+
	| C | S |
	+---+---+
	  0   1

	C = command, B = block number
</pre>
</fieldset>

<h3>Responses</h2>

<fieldset>
<pre>
Name: ERROR
Base10: 5
Description: ERROR has different meaning in different contexts.

	+---+
	| C |
	+---+
	  0

	C = command
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: SLOT_ID
Base10: 6
Description: Sent in response to REQUEST_SLOT. The slot ID is needed to request
hash tree or file blocks. The host has all the blocks for the file. There are
256 different possible slots.

	+---+---+
	| C | S |
	+---+---+
	  0   1

	C = command, S = slot ID
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: SLOT_ID_WITH_BITFIELD
Base10: 6
Description: Sent in response to a REQUEST_SLOT_FILE or a REQUEST_SLOT_HASH. The
slot ID is needed to request hash tree or file blocks. The bitfield
contains bits which symbolize blocks. Bits that are 0 indicate blocks that a
host has. There are 256 different possible slots.

	+---+---+---+---+---+
	| C | S |     B     |
	+---+---+---+---+---+
	  0   1   3  ...  n

	C = command, S = slot ID, B = bitfield of blocks

Bitfield Length:
	(file_size % 8 == 0) ? file_size / 8 : file_size / 8 + 1
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: BLOCK
Base10: 7
Description: Either a hash tree block or file block. The hash tree blocks vary
in size. The file blocks are fixed size except the last block which will be
shorter.

	+---+---+---+---+---+---+---+---+
	| C |             B             |
	+---+---+---+---+---+---+---+---+
	  0   1   2   3   ......... 10240

	C = command, B = block number
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: HAVE_HASH_TREE_BLOCK
Base10: 8
Description: Sent to inform a host that a new hash tree block is available. This
is sent to all hosts that have a open slot for a file.

	+---+---+---+---+---+---+
	| C | S |       B       |
	+---+---+---+---+---+---+
	  0   1   2   3   4   5

	C = command, B = block number
</pre>
</fieldset>

<br>

<fieldset>
<pre>
Name: HAVE_FILE_BLOCK
Base10: 9
Description: Sent to inform a host that a new file block is available. This is
sent to all hosts that have a open slot for a file.

	+---+---+---+---+---+---+
	| C | S |       B       |
	+---+---+---+---+---+---+
	  0   1   2   3   4   5

	C = command, B = block number
</pre>
</fieldset>

<br>

<h2>Pipelining</h2>
<p>
Pipelining is done by sending multiple requests, and a new request whenever a
response is received. This increases throughput because the sender will never be
idle waiting for a request.
</p>
<p>
The maximum allowed pipeline size is 16.
</p>
<h3>
Adaptive Pipeline Sizing Algorithm:
</h3>
<p>
This simple algorithm reduces the size of the pipeline to the minimum needed
without reducing throughput.
</p>
<pre>
Run after request fulfilled to adjust pipeline size.

C = current requests unfulfilled (requests in pipeline)
M = maximum pipeline size (this is what we adjust)
A = absolute maximum pipeline size (M always < A)

case: C == 0 && M < A
	//pipeline is too small, increase by one
	++M
case: C == 1
	//pipeline size optimal, do nothing
case: C > 1 && M > 1
	//pipeline is too large, decrease by one
	--M;
</pre>

<hr>

<h2>Hash Tree</h2>

<p>
Merkle Hash Trees are used to distribute downloading of hash data needed to
verify the integrity of file blocks. The hash "function" used to generate the
tree is SHA1.
</p>

<p>
The bottom row of the tree consists of hashes for every 10240 bytes of the file
(however the last block may be shorter). Every row above the bottom row consists
of hashes for blocks of 512 hashes in the row below it (the last hash may be
for less than 512 child hashes).
</p>

<p>
When the row generation process generates a row of one hash the file size
(encoded in big endian) is prepended to that hash, then that is hashed to
produce the hash the files will be tracked by.
</p>

<p>
The hash tree is addressible by hash blocks. Hash block 0 is the root hash
of the tree with the file size prepended. Hash block 1 is the group of hashes
in the second row that the root hash is a hash for. The hash blocks are not
relative record numbers so to know the size of each block when downloading tree
building must be simulated to determine how many bytes are in each hash block.
</p>

<hr>

<h2>Building</h2>

<h3>GNU/Linux</h3>
<p>
There are many different GNU/Linux distributions. Most likely you can use your
package manager to install the developer versions of these packages: boost, and
gtkmm.
</p>

<h3>Windows</h3>

<p>
<a href="http://www.microsoft.com/express/vc/">Visual C++ Express 2008</a><br>
The command line compiler will be used by scons. It is not necessary to register
unless one wants to use the IDE.
</p>

<p>
<a href="http://www.boostpro.com/products/free">Boost</a> &#62;= 1.36<br>
Precompiled boost is available from Boost Consulting. When installing select the
multithreaded static libs.
</p>

<p>
<a href="http://ftp.gnome.org/pub/GNOME/binaries/win32/gtkmm/">gtkmm</a><br>
Install to "C:\gtkmm" or pkg-config won't work properly. The latest version
known to work is 2.16.0-4.
</p>

<p>
<a href="http://python.org/download/">Python</a><br>
This is used to run the build system (SCons).
</p>

<p>
After installing the dependencies open cmd.exe, navigate to the source directory
and run "scons".
</p>

</tr></td>
</table>

</body>
</html>
