Is it possible to use a static data member in a thread safe way?
================================================================
yes!

To do this boost::once_flag and boost::call_once can be used. The call_once
function must be called before calling any of the static accessor functions. We
don't use static data members because initialization of those isn't thread safe.
However, static objects in functions are instantiated on first use. We exploit
this to make sure the static objects are instantiated by only one thread.

template<typename DUMMY=int>
class test
{
public:
	test()
	{
		boost::call_once(init, once_flag);
	}

private:
	static boost::once_flag once_flag;

	//called to do thread safe static initialization
	static void init()
	{
		mutex();
	}

	//accessor function for static object
	static boost::mutex & mutex()
	{
		static boost::mutex M;
		return M;
	}
};
template<typename DUMMY> boost::once_flag test<DUMMY>::once_flag = BOOST_ONCE_INIT;
