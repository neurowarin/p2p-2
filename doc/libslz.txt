Serialize
=========
The serialize library is similar to protocol buffers.
http://code.google.com/apis/protocolbuffers/docs/encoding.html#structure

However, it is NOT compatible.

There are two primitives in the protocol. The vint (variable length unsigned
int) and the message.

vint
====
All vints are unsigned and little-endian. Each byte in a vint only uses 7 bits
to store data, the MSB (most sig bit) is used to indicate if there is another
byte in the vint. Vints can be a maximum of 10 bytes to support 64bit integers.

	+---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+
	| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | + | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
	+---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+
	  7   6   5   4   3   2   1   0       7   6   5   4   3   2   1   0
                byte 0                              byte 1

This example shows a vint which stores 128. Byte 0 has the MSB set to indicate
that another byte follows. Byte 1 doesn't have the MSB set to indicate it is the
last byte. Byte 1 has it's LSB (least sig bit) set which is a data bit. Since
the 8th data bit is set this vint is equal to 128.

Signed integers can be converted to unsigned vints shifting them left by 1 and
using the LSB for the sign bit. The code for this:

boost::uint64_t encode_int(const boost::int64_t x)
{
	return (x << 1) ^ (x >> 63);
}

boost::int64_t decode_int(const boost::uint64_t x)
{
	return (x >> 1) ^ -static_cast<boost::int64_t>(x & 1);
}


message
=======
Each message starts with a vint which is the message length. This is followed by
another vint which is the message ID.
