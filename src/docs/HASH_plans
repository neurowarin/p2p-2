Create a hash_tree_arbiter and file_arbiter class. They should both probably be
singletons.

Also, the hash_tree_arbiter should probably be the only class that has access to
DB_hash (think about this though).

The hash_tree_arbiter will maintain a std::set<hash> protected by mutex. All
access to hashes will be done through this class so it can arbitrate everything
(provide mutual exclusion).

enum status{
	GOOD, //hash block appended to buff
	BAD,    //hash tree no longer exists
	WAIT    //hash tree downloading but hash block not available yet
};

Whenever a hash_tree_arbiter function gets called with a hash it doesn't have in
memory it should do a database query so that it can get information about the
hash tree. If the hash tree is downloading the arbiter will have to keep track
of what blocks are available for reading. The hashes should be timed out when
not in use. This timeout should be set to the connection timeout.
The hash_tree::check function will update the highest good hash block with the
hash_tree_arbiter. When hash_tree::check says the highest block good is the last
block the state of the hash_tree element will change to complete.

Add an additional state to the hash table.
3 - downloading
This will be needed so that the hash_tree_arbiter can tell whether a hash tree
is downloading. If the file is downloading there will still be an entry in
downloading. Without this state the hash_tree_arbiter wouldn't know if the hash
tree was complete or not. This additional state can also be used to skip hash
tree checks upon program start.

/*
Read specified block from tree. Block appended to buff (if return status ==
GOOD).
*/
status read_block(hash_tree::tree_info & Tree_Info, const boost::uint64_t & block_num,
std::string & buff);

/*
Write specified block to tree. Always succeeds.
May block for a short time if tree is being moved.
*/
void write_block(hash_tree::tree_info & Tree_Info, const boost::uint64_t & block_num,
const std::string & block);

/*
Updates the highest good block available for upload. This should be called by
hash_tree::check. 
*/
void update_highest_good(const std::string & hash, const boost::uint64_t & block_num);

/*
IMPLEMENT THIS LAST

Move a hash tree. Used when compacting. This operation blocks all access to the
hash tree while it runs.

Flags the hash tree as modified. See MODIFIED below.

begin_offset should be location (byte offset from start of file) of start of
hash tree.
end_offset should be the location to move the hash tree to.
size is the size of the hash tree.

see MOVE OPERATION
*/
void move(const std::string & hash, const boost::uint64_t & begin_offset,
const boost::uint64_t & end_offset, const boost::uint64_t & size);

MODIFIED NOTE:
The hash tree modification should be implemented with a counter. There should be
a modification counter inside the hash_tree_arbiter for the specific tree, and a
counter within all tree_info's. This counter should start at 0 in both
locations. Whenever the location of a hash tree is modified this counter within
hash_tree_arbiter should be incremented. All functions which depend upon the
location of the hash tree should always check this counter. If the counter
within hash_tree_arbiter is higher than the one in tree_info then DB_hash should
be used to obtain updated information. After updated information is obtained the
counter in tree_info should be set equal to the counter in hash_tree_arbiter.
