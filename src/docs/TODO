TODO

-move the following in p2p in to a threadsafe singleton called "sockets"
	atomic_int<int> connections;     //currently established connections
	atomic_int<int> max_connections; //connection limit
	fd_set master_FDS;      //master file descriptor set
	fd_set read_FDS;        //holds what sockets are ready to be read
	fd_set write_FDS;       //holds what sockets can be written to without blocking
	atomic_int<int> FD_max; //number of the highest socket
	int localhost_socket;
	std::map<int, time_t> Last_Seen;
turn the p2p_new_connection class in to a singleton

-there is a burst of speed upon program start, a result of averaging over
multiple seconds, and no second_bytes being set.

-change iteration like this
std::container::iterator iter_cur, iter_end
iter_cur = my_container.begin();
iter_end = my_container.end();
to
std::container::itertator
iter_cur = my_container.begin();
iter_end = my_container.end();

-last seen should be set in socket service loop, not in p2p_buffer

-rename global.hpp to settings.hpp and make appropriate namespace change.

-replace send/recv buffers with custom string container which guarantee's it
doesn't do copy on write (to be threadsafe).

-break off response and request stuff from send_buffer in to send_buffer_request
and send_buffer_response.

-grep for all exit(1) instances. If it is debug code surround it with #ifndef NDEBUG

-requests should be sent before file blocks, when two hosts download from
eachother the file blocks hog upload that should be used to get requests out.


A-TAG IDEA
-Have file information stored in a 48 byte file name. This file would not be
shared because it would contain zero bytes. HTTP servers could serve this in
an A-TAG that the p2p frontend could interpret.
<a href="ABCHEX48BYTES">Name of File</a>


THINK ABOUT

-There could be an urgent response that bypasses the pipeline. To do this each
message in the send buffer would have to be kept track of separately. This way
a urgent message could be inserted.
-Using new primes must be forced. To do this old primes must be kept track of.
-Think about CMWC4096 PRNG seed issue. After key exchange, each client/server
sends 1/2 the size of the PRNG seed encrypted to the other.
-Think about how ISP might detect protocol via knowing handshake size/port.
Initial send sizes need to be be randomized? Perhaps do a modulo of some number
against the secret key, this could say how many extra random bytes to send.
-Possible system to do uploads. Favor the highest request, but assure that
requests are arriving sequentially. Actually this wouldn't have to be assured,
if someone started downloading mid file to try to get an advantage they might
have to wait a long time to download the beginning of the file.


DEFERRED FEATURES

-SQLite blob write offset is a signed int. This limits the maximum tree size
to 2gB. Create document like this: http://www.sqlite.org/limits.html with size
limits.
-have temp directory for files that aren't done downloading
-client::set_download_directory() not doing anything but saving setting.
-Support for multiple share directories.
-Figure out how to handle naming conflicts. It should be fully automatic.
Probably just rename the files according to some rules. It doesn't matter too
much since the hashes stay the same.
-Have a directory where partially downloaded files reside. When a file finishes
downloading it can be moved to a directory which can be indexed normally. This
way users can rename files and do what they want and files will just get
rehashed without complication.
-Have a tab that shows share stats, upload/download stats, duplicate files, etc.
-Make sure program works when out of hard drive space.
-Graylist feature to blacklist.
