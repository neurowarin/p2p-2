TODO

-make hash_tree threadsafe, use a little more memory

-check every database call in the program to make sure changes do database
classes have been considered.

-add stop/start functions to download, and rename cancel to remove


HEADER ANNOTATIONS

THREADSAFE      - object is internally locked and threadsafe
NON-THREADSAFE  - object not threadsafe
THREAD SPAWNING - instantiating or calling member functions of this object may spawn threads
SINGLETON       - class implements singleton design pattern


KEY EXCHANGE ALGORITHM
-Client connects and sends his host key.
A. I've seen his host key before and send a "tell me what I said" packet.
	1. he sends incorrect response, I disconnect
	2. he sends correct response, session is open
B. I haven't seen his host key before, I trigger key exchange.

Get this all fleshed out and make detailed html page describing procedure. Maybe
do flow chart.


THINK ABOUT

-Think about having a link on a webpage you could click to run the p2p program.
The paramter could be all the info needed to dl the file.
-Think about CMWC4096 PRNG seed issue. After key exchange, each client/server
sends 1/2 the size of the PRNG seed encrypted to the other.
-Think about how ISP might detect protocol via knowing handshake size/port.
Initial send sizes need to be be randomized? Perhaps do a modulo of some number
against the secret key, this could say how many extra random bytes to send.
-Possible system to do uploads. Favor the highest request, but assure that
requests are arriving sequentially. Actually this wouldn't have to be assured,
if someone started downloading mid file to try to get an advantage they might
have to wait a long time to download the beginning of the file.


DEFERRED FEATURES

-SQLite blob write offset is a signed int. This limits the maximum tree size
to 2gB. Create document like this: http://www.sqlite.org/limits.html with size
limits.
-have temp directory for files that aren't done downloading
-client::set_download_directory() not doing anything but saving setting.
-Support for multiple share directories.
-Figure out how to handle naming conflicts. It should be fully automatic.
Probably just rename the files according to some rules. It doesn't matter too
much since the hashes stay the same.
-Have a directory where partially downloaded files reside. When a file finishes
downloading it can be moved to a directory which can be indexed normally. This
way users can rename files and do what they want and files will just get
rehashed without complication.
-Have a tab that shows share stats, upload/download stats, duplicate files, etc.
-Make sure program works when out of hard drive space.
-Graylist feature to blacklist.
