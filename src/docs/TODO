TODO

-move speed_calculator to include, make more general. remove "bytes", etc..

-make classes separate request and response stuff in p2p_buffer. Put these in
and then convert the p2p_buffer to a singleton.

-think about breaking off p2p in to static lib

-should database wrapper be moved somewhere? libsqlite or include?

-think about having state transitions for everything, not just download_hash_tree
to download_file, state which would need to be passed could be done with some
class and a shared_ptr.

-try forcing slot over 127 to make sure int to char conversion works

-connections with no running downloads not getting terminated

-change iteration like this
std::container::iterator iter_cur, iter_end
iter_cur = my_container.begin();
iter_end = my_container.end();
to
std::container::itertator
iter_cur = my_container.begin();
iter_end = my_container.end();

-replace send/recv buffers with custom string container which guarantee's it
doesn't do copy on write (to be threadsafe). Add functions which do conversions
for all types wrapped up in buffer::append. get rid of two diff types of encrypt
functions after doing this.

-requests should be sent before file blocks, when two hosts download from
eachother the file blocks hog upload that should be used to get requests out.


A-TAG IDEA
-Have file information stored in a 48 byte file name. This file would not be
shared because it would contain zero bytes. HTTP servers could serve this in
an A-TAG that the p2p frontend could interpret.
<a href="ABCHEX48BYTES">Name of File</a>


THINK ABOUT

-There could be an urgent response that bypasses the pipeline. To do this each
message in the send buffer would have to be kept track of separately. This way
a urgent message could be inserted.
-Using new primes must be forced. To do this old primes must be kept track of.
-Think about CMWC4096 PRNG seed issue. After key exchange, each client/server
sends 1/2 the size of the PRNG seed encrypted to the other.
-Think about how ISP might detect protocol via knowing handshake size/port.
Initial send sizes need to be be randomized? Perhaps do a modulo of some number
against the secret key, this could say how many extra random bytes to send.
-Possible system to do uploads. Favor the highest request, but assure that
requests are arriving sequentially. Actually this wouldn't have to be assured,
if someone started downloading mid file to try to get an advantage they might
have to wait a long time to download the beginning of the file.


DEFERRED FEATURES

-SQLite blob write offset is a signed int. This limits the maximum tree size
to 2gB. Create document like this: http://www.sqlite.org/limits.html with size
limits.
-have temp directory for files that aren't done downloading
-client::set_download_directory() not doing anything but saving setting.
-Support for multiple share directories.
-Figure out how to handle naming conflicts. It should be fully automatic.
Probably just rename the files according to some rules. It doesn't matter too
much since the hashes stay the same.
-Have a directory where partially downloaded files reside. When a file finishes
downloading it can be moved to a directory which can be indexed normally. This
way users can rename files and do what they want and files will just get
rehashed without complication.
-Have a tab that shows share stats, upload/download stats, duplicate files, etc.
-Make sure program works when out of hard drive space.
-Graylist feature to blacklist.
