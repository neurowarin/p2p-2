BUGS AND NECESSARY FEATURES

-Sometimes when terminating download downloads get "stuck". If the download 
and serverElements are removed before a full response to the latest request the
client will try to send another request to a socket that's not ready for it,
fouling things up.

-download::processBuffer() needs a mechanism to disconnect abusive servers.

-Program crashes if trying to resume download where the user has removed the partial
file.

-There is no check for a download already completed by the download feature.
For example it's possible to download a file that's already been downloaded and
it will just append to the end of the already downloaded file.

-If the download directory is missing and a download is started the directory
is not created automatically.


POSSIBLE FEATURES

-Consider having the IP's in the infoBuffers put in a vector instead of being
all put in a string.

-Client has no control of how many connections it will try to make. Add it.

-client::addBlock() has string copying in it, could be a performance problem.

-Add a check to make sure the client is not requesting the same blocks over
and over(trying to waste bandwidth to degrade serving capability).

-Have the serverIndex poll to check for new files added to share.

-Come up with a indexing scheme for search.db(it'll get big).

-Reduce control data size by encoding file and fileBlock numbers. Also, perhaps
negotiate control data size for each download.

-Information in the gui statusbar for protocol overhead.


IDEAS

-Overhead can be reduced a lot. The client doesn't need to know what file_ID
the server is sending because it tracks everything by the socket number. The
client also doesn't need to know the fileBlock because it can expect the server
to send the block that was requested. For that matter what the server is doing
"BLS" also doesn't need to be known.

-Locating files should be done on a tiered linear network. Hosts should connect to
eachother in a sequential way on level 1 but in other ways on the other levels to
make it so the client can start traversing the network on the level which is closest.

Tier 1: Linear
Tier 2: Random

Question: How would tier 1 remain connected at all times?
Question: How to insure roughly the same access time to any node?

