TODO

-the main client thread is doing transitions, that should be handled by a diff
thread.

-Should keep track of the lowest socket number to limit loops. Problem is
bad on windows.

-Make pipeline size dynamic such that it increases every time 0 is hit, up to a
max value of 8.

-Get client_server_bridge working for hash trees. Use the hash tree recursive
function to figure out how many blocks are in each row so it's known when blocks
are checked.

-Sometimes gui download stat file percent complete stops at 99% when file is
complete.

-Store primes in DB as base 64.


DEFERRED FEATURES

-When connecting to a server have the client send it's host key and then the
server send it's host key. Both the client and server should look to see if a
key has been negotiated with the other before. If it has the client can just
start sending without negotating a new key. Defer this feature until GUIDs
are worked out.

-Make hashing multithreaded. Have one thread that scans the share and queues
files to be hashed. This thread can also calculate % complete. Multiple worker
threads can then get files from a queue to hash. Use the thread pool for this.

-client::set_download_directory() not doing anything but saving setting.

-Support for multiple share directories.

-Total upload/download needs to be kept track of in client_server_bridge. Think
about having a minimum speed on the client/server upload/download (like 1kB/s).
If there's no minimum it could be possible for the client to starve the server
or vise versa. The sleep method in the socket checking loop won't work here
because it would allow writes to slow down reads and visa versa.

-Figure out how to handle naming conflicts. It should be fully automatic.
Probably just rename the files according to some rules. It doesn't matter too
much since the hashes stay the same.

-Combine hash tree's in to one file. Keep track of starting locations in DB.
Perhaps have a memmove type opteration one a file where hashes can be moved to
get rid of gaps due to removed files. The intermediate step of the memmove
operation would basically be a journal.


PROTOCOL IDEAS

-Have a token that can be send to the server from the client which basically asks
the server, "do you want to send data". Token should be offered once every 16
seconds so the server can send information like servers it knows about that the
client does not.


OVERLAY NETWORK IDEAS
