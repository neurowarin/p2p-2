PROTOCOL DOCUMENTATION

/******************************************************************************/
DOCUMENT FORMAT

Command, Full Name
Direction (ie client -> server would indicate from the client to the server)
Description
Byte-Diagram
Possible Responses
Byte-Diagram for Possible Response

/******************************************************************************/
DEFINITIONS

ID  - Short for identification.
RRN - relative record number (determines a byte offset when multiplied by a
      block size).

/******************************************************************************/
GENERAL PROTOCOL INFORMATION

All encoded numbers are unsigned and are in big endian.

Requests to the server are pipelined. The maximum number of unresponded to
commands which can be sent is global::PIPELINE_SIZE. If more than this number
of requests is sent the client will be considered abusive and disconnected. To
maximize performance global::PIPELINE_SIZE requests are sent upon download start
and a new request is sent every time a response is received.

/******************************************************************************/
RE-REQUEST ALGORITHM

A server may be extremely slow or disconnected but not timed out. If either of
these happen it's necessary to re-request the blocks expected from the tardy
server.

The re-request algorithm is based on buffer size and scales with how many servers
the download_file is connected to. Re-requests are linear and will done when:

	B mod(Q) = 0 , where B is the buffer size and

	Q = C * R , where
	            C is the number of servers that are sending blocks
	            R is the re-request factor (constant)

This has the problem of checking extra times when the number of connected
servers fluctuates. For example say there is a check, and right after that another
server is connected, then a check will be done after R more blocks are received.

Re-requests are done from servers that hadn't already had the late block
requested from it.


NOT COMPLETED

/******************************************************************************/
PIPELINING (AKA WINDOWING)

Pipelining is done to avoid dead time (time where no data is being transferred).
Dead time happens with "stop-n-go" protocols where a client will only send a new
request when the response to the previous request is gotten. Pipelining solves
this by having the client send out many requests initially, and then sending
new requests as responses are received. In this way the server maintains a queue
of requests it can process even if new requests are delayed.

Pipelining in this program is done in the client_buffer class to hide most of
the complexity from the downloads. The only requirement for downloads is
that they maintain their own request queues such that they can provide the
client buffer with multiple requests before the client_buffer returns any
responses.

/******************************************************************************/
SPEED COMPENSATION ALGORITHM

Some servers are faster than others. This causes a problem when requesting
blocks from servers in order of what block is needed next. A slow server might
take a long time to send a block. To compensate for this it is necessary to
request blocks farther in the future from slower servers.

To determine how far in the future to lead a request:

	L = D/S , where
	          L is the number of blocks to lead
	          D is the download speed, or sum of all individual server speeds
	          S is the speed of the individual server

L is to be calculated as a float so that values >= .5 can be rounded up and
values < .5 can be rounded down.

If there have been previous requests to the server made the optimal next block
would be the latest request + L. If no requests had yet been made to the server
the optimal next block would be the latest written block + L.

If the optimal next block has already been requested then the block one lower
should be checked for availablility, if that one was already requested then a
block one higher should be checked. Blocks should be checked in this order until
a available block is found.

/******************************************************************************/
P_SBL, Send Block
client -> server

Request a file block from the server by sending the file ID and RRN of the block.

	  0   1   2   3   4   6   7   8   9
	+---+---+---+---+---+---+---+---+---+
	| C |    file ID    |      RRN      |
	+---+---+---+---+---+---+---+---+---+

Possible Responses:

P_BLS, Block Send

The server is sending us the block requested.

	  0   1   2   3   .........  8192
	+---+---+---+---+---+---+---+---+
	| C |        file block         |
	+---+---+---+---+---+---+---+---+


P_DNE, Block Does Not Exist

The server sends this when it is in progress of downloading the file but doesn't
yet have the block requested.

	  0
	+---+
	| C |
	+---+


P_FNF, File Not Found

The server doesn't have the requested file.

	  0
	+---+
	| C |
	+---+

/******************************************************************************/
