PROTOCOL DOCUMENTATION

/******************************************************************************/
GENERAL INFORMATION

All encoded numbers are unsigned and are in big endian.

All packets are sent asynchronously and are delimited by 1 byte commands that
all have associated packet length.

Example Buffer:

	  0   1   2   3   4   6   7   8   9  10  11  12  13  14  15  16  17  18
	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	| C |               | C |                                       | C |   |
	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+

	In this example the first command has an associated length of 5, the second
one has length 11, the third one has length 2.

/******************************************************************************/
RE-REQUEST ALGORITHM

Blocks are rerequested that haven't been received after 4 seconds.

/******************************************************************************/
PIPELINING

Pipelining is done to avoid dead time (time where no data is being transferred).
Dead time happens with "stop-n-go" protocols where a client will only send a new
request when the response to the previous request is gotten. Pipelining solves
this by having the client send out many requests initially, and then sending a
new request as whenever a response is received. In this way the server maintains
a queue of requests it can process even if new requests are delayed.

The maximum pipeline size is 16 commands.

/******************************************************************************/
TIMEOUT

Connection timeout is 16 seconds of inactivity (no I/O).

/******************************************************************************/
P_ERROR (0)
server -> client
Has different meaning and packet length in different contexts.

/******************************************************************************/
P_REQUEST_SLOT_FILE (1)
client -> server

P_REQUEST_SLOT_HASH (2)
client -> server

Request a slot number for downloading a file or hash tree. The slot ID is 1 byte
so 256 slots per connection are supported.

	  0   1   2   3   ........    21
	+---+---+---+---+---+---+---+---+
	| C |         root hash         |
	+---+---+---+---+---+---+---+---+

Possible Responses:

P_SLOT_ID (3)
The slot ID for the file. As long as the connection lasts this slot ID can be
used to request blocks from the associated file. If reconnection happens a new
slot ID needs to be requested.

	  0   1
	+---+---+
	| C | S | , where S = slot ID
	+---+---+

P_ERROR (0)
The server doesn't have the requested file.

	  0
	+---+
	| C |
	+---+

/******************************************************************************/
P_CLOSE_SLOT (4)
client -> server

Tell the server to close a slot.

	  0   1
	+---+---+
	| C | S | , where S = slot ID
	+---+---+

/******************************************************************************/
P_SEND_BLOCK (5)
client -> server
Request either a 5120 byte block from a file or a block of 256 hashes.

	  0   1   2   3   4   .........  10
	+---+---+---+---+---+---+---+---+---+
	| C | S |              RRN          | , where S = slot ID
	+---+---+---+---+---+---+---+---+---+

Possible Responses:

P_BLOCK (6)
The block requested. May be shorter than 5121 if the block requested was the
last block of a file or if there aren't 256 hashes left in a hash tree.

	  0   1   2   3   .........  5121
	+---+---+---+---+---+---+---+---+
	| C |            block          |
	+---+---+---+---+---+---+---+---+


P_ERROR (0)
The server has the file but has not yet downloaded this block. This should
trigger a 8 second delay before trying again.

	  0
	+---+
	| C |
	+---+

/******************************************************************************/
